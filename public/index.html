<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è —ç–∫—Ä–∞–Ω–∞ Mac (WebRTC)</title>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .display-selector {
      background: white;
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    .display-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .display-card {
      background: #f8f9fa;
      border: 3px solid transparent;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .display-card:hover {
      border-color: #667eea;
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }
    
    .display-card.active {
      border-color: #667eea;
      background: #e8ecff;
    }
    
    .display-card img {
      width: 100%;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    
    .display-name {
      font-weight: 600;
      color: #333;
      text-align: center;
    }
    
    .stream-container {
      background: white;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      display: none;
    }
    
    .stream-container.active {
      display: block;
    }
    
    .stream-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .stream-title {
      font-size: 1.3em;
      font-weight: 600;
      color: #333;
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 10px 25px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
    }
    
    .btn-stop {
      background: #e74c3c;
      color: white;
    }
    
    .btn-stop:hover {
      background: #c0392b;
      transform: scale(1.05);
    }
    
    .btn-fullscreen {
      background: #3498db;
      color: white;
    }
    
    .btn-fullscreen:hover {
      background: #2980b9;
      transform: scale(1.05);
    }
    
    .btn-settings {
      background: #9b59b6;
      color: white;
    }
    
    .btn-settings:hover {
      background: #8e44ad;
      transform: scale(1.05);
    }
    
    .settings-panel {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
      display: none;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .settings-panel.active {
      display: block;
    }
    
    .settings-group {
      margin-bottom: 20px;
    }
    
    .settings-group label {
      display: block;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      font-size: 0.95em;
    }
    
    .settings-group select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
      background: white;
      cursor: pointer;
      transition: border-color 0.3s ease;
    }
    
    .settings-group select:hover {
      border-color: #667eea;
    }
    
    .settings-group select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    .settings-info {
      font-size: 0.85em;
      color: #666;
      margin-top: 5px;
      font-style: italic;
    }
    
    .video-wrapper {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: black;
      border-radius: 10px;
      overflow: hidden;
      min-height: 400px;
    }
    
    #video {
      width: 100%;
      max-width: 100%;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      display: block;
      background: black;
      cursor: pointer;
      transition: transform 0.2s ease;
      object-fit: contain;
      object-position: center;
      margin: 0 auto;
    }
    
    #video:hover {
      box-shadow: 0 5px 20px rgba(0,0,0,0.2);
      transform: scale(1.01);
    }
    
    #video:active {
      transform: scale(0.99);
    }
    
    .status {
      text-align: center;
      padding: 15px;
      margin-top: 15px;
      border-radius: 8px;
      font-weight: 500;
    }
    
    .status.connecting {
      background: #fff3cd;
      color: #856404;
    }
    
    .status.connected {
      background: #d4edda;
      color: #155724;
    }
    
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
      font-size: 1.1em;
    }
    
    /* Fullscreen styles - for when video is in native fullscreen */
    video:fullscreen {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      object-position: center;
      background: black;
    }
    
    video:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      object-position: center;
      background: black;
    }
    
    video:-moz-full-screen {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      object-position: center;
      background: black;
    }
    
    video:-ms-fullscreen {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      object-position: center;
      background: black;
    }
    
    @media (max-width: 768px) {
      h1 {
        font-size: 1.8em;
      }
      
      .display-grid {
        grid-template-columns: 1fr;
      }
      
      .stream-header {
        flex-direction: column;
        align-items: stretch;
      }
      
      .btn-group {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üñ•Ô∏è –¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è —ç–∫—Ä–∞–Ω–∞ Mac (WebRTC)</h1>
    
    <div class="display-selector" id="selector">
      <h2 style="margin-bottom: 15px; color: #333;">–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–Ω–∏—Ç–æ—Ä –¥–ª—è —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:</h2>
      <div class="display-grid" id="displayGrid">
        <div class="loading">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–æ–≤...</div>
      </div>
    </div>
    
    <div class="stream-container" id="streamContainer">
      <div class="stream-header">
        <div class="stream-title" id="streamTitle">–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è</div>
        <div class="btn-group">
          <button class="btn btn-fullscreen" onclick="toggleFullscreen()">–ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω</button>
          <button class="btn btn-stop" onclick="stopStream()">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
        </div>
      </div>
      <div class="video-wrapper">
        <video id="video" autoplay playsinline muted></video>
      </div>
      <div class="status" id="status"></div>
    </div>
  </div>

  <script>
    let socket = null;
    let peer = null;
    let displays = [];
    let currentDisplayId = null;
    let currentRoomId = null;
    let isFullscreen = false;
    // Settings are now managed in the Electron app, not in browser
    let currentResolution = null; // Native resolution
    let currentBitrate = 1500000; // Default bitrate
    let currentFPS = 30; // Default FPS
    const video = document.getElementById('video');
    
    // Enable fullscreen on video click
    video.addEventListener('click', toggleFullscreen);

    // Load available displays
    async function loadDisplays() {
      try {
        const response = await fetch('/api/displays');
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.details || error.error || 'Failed to load displays');
        }
        
        const data = await response.json();
        displays = data.displays;
        
        if (displays.length === 0) {
          document.getElementById('displayGrid').innerHTML = 
            '<div class="status error">‚ùå –ú–æ–Ω–∏—Ç–æ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ BetterDisplay –∑–∞–ø—É—â–µ–Ω.</div>';
          return;
        }
        
        renderDisplays();
      } catch (error) {
        console.error('Load displays error:', error);
        document.getElementById('displayGrid').innerHTML = 
          '<div class="status error">‚ùå –û—à–∏–±–∫–∞: ' + error.message + '<br><br>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ "–ó–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞" –≤ –°–∏—Å—Ç–µ–º–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Mac.</div>';
      }
    }

    function renderDisplays() {
      const grid = document.getElementById('displayGrid');
      
      if (displays.length === 0) {
        grid.innerHTML = '<div class="status error">–ú–æ–Ω–∏—Ç–æ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
        return;
      }
      
      grid.innerHTML = displays.map(display => `
        <div class="display-card" onclick="selectDisplay('${display.id}', '${display.name}')">
          <img src="${display.thumbnail}" alt="${display.name}">
          <div class="display-name">${display.name}</div>
        </div>
      `).join('');
    }

    function selectDisplay(displayId, displayName) {
      // Stop any existing connection
      if (peer) {
        peer.destroy();
        peer = null;
      }
      if (socket) {
        socket.disconnect();
        socket = null;
      }
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      currentDisplayId = displayId;
      currentRoomId = 'room-' + displayId + '-' + Date.now();
      document.getElementById('streamTitle').textContent = `–¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è: ${displayName}`;
      document.getElementById('selector').style.display = 'none';
      document.getElementById('streamContainer').classList.add('active');
      connectWebRTC();
    }

    function connectWebRTC() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}`;
      
      console.log('Connecting to Socket.IO:', wsUrl);
      setStatus('connecting', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');

      // Connect to Socket.IO
      socket = io(window.location.origin, {
        transports: ['websocket', 'polling']
      });

      socket.on('connect', () => {
        console.log('Socket.IO connected');
        setStatus('connecting', '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –£—Å—Ç–∞–Ω–æ–≤–∫–∞ WebRTC...');
        
        // Join room
        socket.emit('join-room', {
          roomId: currentRoomId,
          displayId: currentDisplayId
        });
      });

      socket.on('joined', (data) => {
        console.log('Joined room:', data);
        setStatus('connecting', '–û–∂–∏–¥–∞–Ω–∏–µ WebRTC —Å–∏–≥–Ω–∞–ª–∞...');
        
        // Reset peer if it exists (shouldn't happen, but just in case)
        if (peer) {
          console.warn('Peer already exists on join, destroying it');
          peer.destroy();
          peer = null;
        }
      });

      socket.on('webrtc-signal', (data) => {
        console.log('Client received WebRTC signal:', data);
        console.log('Signal type:', data.signal?.type || 'unknown');
        console.log('Current peer state:', peer ? 'exists' : 'null');
        
        if (!peer) {
          // Create SimplePeer as receiver (only on first signal - the offer)
          // Only create if this is an offer signal
          if (data.signal && data.signal.type === 'offer') {
            console.log('Creating SimplePeer as receiver (offer received)');
            // SDP transform function to optimize for low latency
            const sdpTransform = (sdp) => {
              let newSDP = sdp;
              // Set video bitrate to match server (1 Mbps for minimal latency)
              const VIDEO_BITRATE = 2000000; // 1 Mbps
              newSDP = setSdpMediaBitrate(newSDP, 'video', VIDEO_BITRATE);
              return newSDP;
            };
            
            // Helper function to set SDP media bitrate
            function setSdpMediaBitrate(sdp, mediaType, bitrate) {
              const sdpLines = sdp.split('\n');
              let mediaLineIndex = -1;
              const mediaLine = `m=${mediaType}`;
              let bitrateLineIndex = -1;
              const bitrateLine = `b=AS:${bitrate}`;
              mediaLineIndex = sdpLines.findIndex((line) => line.startsWith(mediaLine));

              if (mediaLineIndex && mediaLineIndex < sdpLines.length) {
                bitrateLineIndex = mediaLineIndex + 1;
                while (
                  sdpLines[bitrateLineIndex] && (
                    sdpLines[bitrateLineIndex].startsWith('i=') ||
                    sdpLines[bitrateLineIndex].startsWith('c=')
                  )
                ) {
                  bitrateLineIndex += 1;
                }

                if (sdpLines[bitrateLineIndex] && sdpLines[bitrateLineIndex].startsWith('b=')) {
                  sdpLines[bitrateLineIndex] = bitrateLine;
                } else {
                  sdpLines.splice(bitrateLineIndex, 0, bitrateLine);
                }
              }
              return sdpLines.join('\n');
            }

            peer = new SimplePeer({
              initiator: false,
              trickle: true, // Enable trickle ICE for lower latency
              sdpTransform: sdpTransform,
              config: {
                iceServers: [],
                iceCandidatePoolSize: 0 // Don't pre-gather candidates
              }
            });
          } else {
            console.log('Ignoring signal - not an offer and peer not created yet');
            return;
          }

          peer.on('signal', (signal) => {
            console.log('Client sending WebRTC signal (answer)');
            socket.emit('webrtc-signal', {
              roomId: currentRoomId,
              socketId: socket.id,
              signal: signal
            });
          });

          peer.on('stream', (stream) => {
            console.log('Client received MediaStream!', stream);
            console.log('Stream tracks:', stream.getTracks().length);
            console.log('Video tracks:', stream.getVideoTracks().length);
            console.log('Video track settings:', stream.getVideoTracks()[0]?.getSettings());
            
            if (stream.getVideoTracks().length === 0) {
              console.error('No video tracks in stream!');
              setStatus('error', '–û—à–∏–±–∫–∞: –Ω–µ—Ç –≤–∏–¥–µ–æ —Ç—Ä–µ–∫–æ–≤ –≤ –ø–æ—Ç–æ–∫–µ');
              return;
            }
            
            video.srcObject = stream;
            video.onloadedmetadata = () => {
              console.log('Video metadata loaded, dimensions:', video.videoWidth, 'x', video.videoHeight);
              // Ensure video is centered and properly sized
              video.style.width = '100%';
              video.style.height = 'auto';
              video.style.objectFit = 'contain';
              video.style.objectPosition = 'center';
            };
            video.onplay = () => {
              console.log('Video started playing');
              setStatus('connected', '‚úì –¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞ (WebRTC)');
            };
            video.onerror = (err) => {
              console.error('Video error:', err);
              setStatus('error', '–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –≤–∏–¥–µ–æ');
            };
            
            video.play().catch(err => {
              console.error('Error playing video:', err);
              setStatus('error', '–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤–∏–¥–µ–æ: ' + err.message);
            });
          });

          peer.on('connect', () => {
            console.log('Client WebRTC connected');
            setStatus('connected', '‚úì WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
          });

          peer.on('error', (err) => {
            console.error('Client WebRTC error:', err);
            setStatus('error', '–û—à–∏–±–∫–∞ WebRTC: ' + err.message);
          });

          peer.on('close', () => {
            console.log('Client WebRTC closed');
            setStatus('error', 'WebRTC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ');
          });
        }
        
        // Signal the peer (process offer/answer/ICE candidates)
        if (peer) {
          try {
            console.log('Client signaling peer with received signal');
            peer.signal(data.signal);
          } catch (err) {
            console.error('Error signaling peer:', err);
          }
        }
      });

      socket.on('disconnect', () => {
        console.log('Socket.IO disconnected');
        setStatus('error', '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ');
      });

      socket.on('error', (error) => {
        console.error('Socket.IO error:', error);
        setStatus('error', '–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ' + error.message);
      });
    }

    function stopStream() {
      if (peer) {
        peer.destroy();
        peer = null;
      }
      
      if (socket) {
        socket.disconnect();
        socket = null;
      }
      
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      
      // Exit fullscreen if active
      if (isFullscreen) {
        exitFullscreen();
      }
      
      document.getElementById('selector').style.display = 'block';
      document.getElementById('streamContainer').classList.remove('active');
      currentDisplayId = null;
      currentRoomId = null;
    }

    function toggleFullscreen() {
      if (isFullscreen) {
        exitFullscreen();
      } else {
        enterFullscreen();
      }
    }

    function enterFullscreen() {
      // Use native Fullscreen API - request fullscreen on video element
      if (video.requestFullscreen) {
        video.requestFullscreen().then(() => {
          updateFullscreenButton(true);
        }).catch(err => {
          console.log('Error attempting fullscreen:', err);
        });
      } else if (video.webkitRequestFullscreen) {
        // Safari
        video.webkitRequestFullscreen();
        updateFullscreenButton(true);
      } else if (video.webkitEnterFullscreen) {
        // iOS Safari
        video.webkitEnterFullscreen();
        updateFullscreenButton(true);
      } else if (video.mozRequestFullScreen) {
        // Firefox
        video.mozRequestFullScreen();
        updateFullscreenButton(true);
      } else if (video.msRequestFullscreen) {
        // IE/Edge
        video.msRequestFullscreen();
        updateFullscreenButton(true);
      } else {
        console.warn('Fullscreen API not supported');
      }
    }

    function exitFullscreen() {
      // Exit native fullscreen
      if (document.exitFullscreen) {
        document.exitFullscreen().catch(err => {
          console.log('Error exiting fullscreen:', err);
        });
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    
    function updateFullscreenButton(fullscreen) {
      const btn = document.querySelector('.btn-fullscreen');
      if (btn) {
        btn.textContent = fullscreen ? '–í—ã–π—Ç–∏ –∏–∑ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞' : '–ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω';
      }
      isFullscreen = fullscreen;
    }
    
    // Listen for fullscreen changes (including ESC key)
    document.addEventListener('fullscreenchange', () => {
      const isCurrentlyFullscreen = !!(document.fullscreenElement || 
                                       document.webkitFullscreenElement || 
                                       document.mozFullScreenElement || 
                                       document.msFullscreenElement);
      updateFullscreenButton(isCurrentlyFullscreen);
    });
    
    document.addEventListener('webkitfullscreenchange', () => {
      const isCurrentlyFullscreen = !!document.webkitFullscreenElement;
      updateFullscreenButton(isCurrentlyFullscreen);
    });
    
    document.addEventListener('mozfullscreenchange', () => {
      const isCurrentlyFullscreen = !!document.mozFullScreenElement;
      updateFullscreenButton(isCurrentlyFullscreen);
    });
    
    document.addEventListener('MSFullscreenChange', () => {
      const isCurrentlyFullscreen = !!document.msFullscreenElement;
      updateFullscreenButton(isCurrentlyFullscreen);
    });

    function setStatus(type, message) {
      const statusEl = document.getElementById('status');
      statusEl.className = `status ${type}`;
      statusEl.textContent = message;
    }

    // Handle ESC key for exiting fullscreen (native API handles this automatically, but we can add extra handling)
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        // Check if we're in fullscreen
        const isCurrentlyFullscreen = !!(document.fullscreenElement || 
                                         document.webkitFullscreenElement || 
                                         document.mozFullScreenElement || 
                                         document.msFullscreenElement);
        if (isCurrentlyFullscreen) {
          exitFullscreen();
        }
      }
    });

    // Load displays on page load
    loadDisplays();
  </script>
</body>
</html>

